---
title: "Merge, descripive and statistical analysis"
author: "Nelly"
date: "2024-03-15"
output:
  word_document: default
  pdf_document: default
  html_document: default
---

```{r}
library(readxl)
library(grabr)
library(gagglr)
library(tidyverse)
library(glamr)
library(glitr)
library(gophr)
library(extrafont)
library(scales)
library(tidytext)
library(glue)
library(janitor)
library(ggtext)
library(extrafont)
library(patchwork)
library(knitr)
library(readr)
library(openxlsx)
library(stringr)
```

# set filepath
```{r}
# data_folder <- "Data"
# data_folder %>% return_latest()
ml_path <- "Dataout/masterclientlist.rds"
ml_dfclean <- read_rds(ml_path)
```

```{r}
# data_folder <- "Data"
# data_folder %>% return_latest()
vl_path <- "Dataout/vldata.rds"
vl_dfclean <- read_rds(vl_path)
```



```{r}
vl_dfclean %>% 
    group_by(merge_id) %>% 
    filter(n() > 1)
```



```{r}
dupl <- vl_dfclean[vl_dfclean %>% 
    select(merge_id, datetested) %>% 
    duplicated(), ] 
```


```{r}
vl_df_clean_wide<- vl_dfclean %>% 
      group_by(merge_id) %>% 
      filter(datetested == min(datetested) | datetested == max(datetested)) %>% 
      mutate(type = ifelse(datetested == min(datetested), "start", "end")) %>% 
      group_by(merge_id, type) %>% 
      filter(row_number() == 1) %>% 
      ungroup() %>% 
      select(-result,-datetested) %>% 
      pivot_wider(names_from = type,
                  values_from = vlsup_cat)
```

```{r}
vl_df_clean_wide<-vl_dfclean %>% 
     group_by(merge_id) %>% 
     mutate(rank = rank(datetested, ties.method = "first")) %>% 
     filter(rank == min(rank) | rank == ceiling(max(rank)/2) | rank == max(rank)) %>% 
     arrange(merge_id, datetested) %>%
     mutate(rank = rank(rank)) %>% 
     pivot_wider(names_from=rank, values_from = rank, names_prefix = "V")
```


```{r}

 vl_df_clean_wide <- vl_dfclean %>%
   group_by(merge_id) %>% 
   # Rank by date tested
   mutate(rank = rank(datetested, ties.method = "first")) %>%
   # Determine total number of observations per group
   mutate(total = n()) %>%
   # For groups with 3 or more, take first, middle, last
   # For groups with 2, take first and last
   # For groups with 1, take only available
   filter(
     (total >= 3 & (rank == 1 | rank == ceiling(total/2) | rank == total)) |
     (total == 2 & (rank == 1 | rank == 2)) |
     (total == 1 & rank == 1)
   ) %>%
   # Assign V1, V2, V3 based on filtered ranks
   mutate(rank = case_when(
     rank == 1 ~ "V1",
     rank == 2 & total == 2 ~ "V2",
     total >= 3 & rank == ceiling(total/2) ~ "V2",
     rank == total ~ "V3"
   )) %>%
   # Pivot wider with names from the new rank
   pivot_wider(
     names_from = rank, 
     values_from = c(result, datetested, vlsup_cat), 
     names_prefix = ""
   ) %>%
   # Remove the group by status after pivoting
   ungroup() %>% 
  # mutate(vlsup_cat_V3 = ifelse(is.null(vlsup_cat_V3), vlsup_cat_V3, vlsup_cat_V2))
 
 
 # View the results to confirm
 print(vl_df_clean_wide)

```


```{r}

vl_df_clean_wide <- vl_dfclean %>%
  group_by(merge_id) %>% 
# Rank by date tested
 mutate(rank = rank(datetested, ties.method = "first")) %>%
# Determine total number of observations per group
mutate(total = n()) %>%
# For groups with 3 or more, take first, middle, last
# For groups with 2, take first and last
# For groups with 1, take only available
filter(
 (total >= 3 & (rank == 1 | rank == ceiling(total/2) | rank == total)) |
  (total == 2 & (rank == 1 | rank == 2)) |
 (total == 1 & rank == 1)
) %>%
# Assign V1, V2, V3 based on filtered ranks
 mutate(rank = case_when(
 rank == 1 ~ "V1",
 rank == 2 & total == 2 ~ "V2",
 total >= 3 & rank == ceiling(total/2) ~ "V2",
 rank == total ~ "V3"
)) %>%
# Pivot wider with names from the new rank
pivot_wider(
 names_from = rank, 
 values_from = c(result, datetested, vlsup_cat), 
 names_prefix = "" ) %>%
 # Remove the group by status after pivoting
ungroup() %>% 
mutate(result_V3_aux = ifelse(is.na(result_V3), result_V2, result_V3), .after="result_V3",
       result_V2 = ifelse(is.na(result_V3), NA, result_V2),
       result_V3 = result_V3_aux) %>% 
mutate(vlsup_cat_V3_aux = ifelse(is.na(vlsup_cat_V3), vlsup_cat_V2, vlsup_cat_V3),
       vlsup_cat_V2 = ifelse(is.na(vlsup_cat_V3), NA, vlsup_cat_V2),
       vlsup_cat_V3 = vlsup_cat_V3_aux) %>% 
select(-result_V3_aux, -vlsup_cat_V3_aux)
  
# created Aux variable to help check if the movement from V2 to v3 for observations with only 2 vls have moved correctly then deleted the aux variable 


```


## Perform a full join on ml_dfclean and vl_dfclean  using a common key'merge_id'
```{r}

df1 <- tidylog::full_join(ml_dfclean, vl_df_clean_wide, by = "merge_id")

```
# remove 343 clients observations without VL data 
```{r}
df1_filtered <- df1 %>%
  dplyr::filter(!is.na(vlsup_cat_V1) | !is.na(vlsup_cat_V3))
```

Recoding the non intervention group 
```{r}
df1_filtered$intervention <- ifelse(is.na(df1_filtered$intervention), "Control", df1_filtered$intervention)

```



```{r}
# Recode specified levels into a single category "Relatives"
df1_filtered <- df1_filtered %>%
  mutate(parenthood_status_combined = case_when(
    parenthood_status %in% c("Work place", "wife", "Husband", 
                             "Grand Parents", "Child headed", 
                             "Caregiver mentor", "OVC") ~ "Relatives",
    TRUE ~ as.character(parenthood_status)
  ))
```




# recode variables to factors
```{r}
factor_columns <- c(
  "assessment_type", "age", "sex", "recommend_services", "q1_impact",
  "healthy_symptom_free_frequency", "symptoms_impacted_q1", "experienced_symptoms_last_2_weeks",
  "problem_experience_last_2_weeks", "support_from_family_friends", "hiv_discrimination_past_month",
  "factors_impacted_score_most", "hiv_treatment_expenses_loan_sold", "specific_expenses_for_treatment",
  "art_dispensed_last_contact", "preferred_art_dispensed", "unsuppressed_calhiv_dsd_approach",
  "preferred_hiv_services_method", "preferred_dsd_choice", "attach_to_chw",
  "parenthood_status", "factors_impacted_score_most_aggregated", "intervention", "vlsup_cat_V1", "vlsup_cat_V2","vlsup_cat_V3"
)

df1_filtered <- df1_filtered %>%
  mutate(merge_id = as.character(merge_id))



df1_filtered <- df1_filtered %>%
  mutate(across(c(interview_date, datetested_V1, datetested_V2, datetested_V3),
                ~ as.Date(sub("^\\d+\\s+", "", .), format = "%Y-%m-%d")))

df1_filtered <- df1_filtered %>%
  mutate_at(vars(all_of(factor_columns)), as.factor)
```

```{r}

df1_filtered <- df1_filtered %>%
  mutate(intervention = recode(intervention,
                               'intervention' = '1',
                               'Control' = '0'))
```


#descriptive statistics 


```{r}

# Adjusting the subset to include only those with "Yes" in the intervention column
intervention_subset <- df1_filtered[df1_filtered$intervention == "1", ]
# Set the factor levels for the 'age' variable
intervention_subset$age <- factor(intervention_subset$age, 
                                  levels = c("0-4 Years", "5-9 Years", "10-14 Years", "15-19 Years"))

# Create the age-sex pyramid plot directly from the intervention subset
ggplot(data = intervention_subset, aes(x = age, fill = sex)) +
  geom_bar(data = subset(intervention_subset, sex == "Male"), aes(y = ..count..), stat = "count") +
  geom_bar(data = subset(intervention_subset, sex == "Female"), aes(y = -..count..), stat = "count") +
  geom_text(data = subset(intervention_subset, sex == "Male"), aes(label = ..count.., y = ..count../2), stat = "count", size = 3) +
  geom_text(data = subset(intervention_subset, sex == "Female"), aes(label = ..count.., y = -..count../2), stat = "count", size = 3) +
  scale_fill_manual(values = c("Female" = "#8980CB", "Male" = "#287C6F")) +
  coord_flip() +  # Flip the axes to put age groups on the y-axis
  scale_y_continuous(labels = abs) +  # Use absolute values for count labels
  labs(x = "Count", y = "Age Group", fill = "Sex", title = "Age-Sex Pyramid for Intervention Group",
       caption = "Source: PCM 2024 data") +
  theme_minimal() +
  theme(
    plot.margin = unit(c(1, 1, 1, 1), "cm"),
    panel.spacing = unit(0.05, "lines"),
    panel.grid.major = element_blank(),  # Removes major grid lines
    panel.grid.minor = element_blank(),  # Removes minor grid lines
    plot.title = element_text(size = 13, face = "bold", hjust = 0.5, vjust = 1),  # Center aligns the title
    strip.text = element_text(size = 11, vjust = 1),
    axis.text.x = element_text(size = 9),
    axis.text.y = element_text(size = 9),
    plot.caption = element_text(size = 9, color = "grey50", hjust = 1, margin = margin(t = 15)),
    legend.position = "none"
  )

```


 # DISTRIBUTION by caregiver
 
```{r}
# Convert the combined parenthood status to a factor
df1_filtered$parenthood_status_combined <- factor(df1_filtered$parenthood_status_combined)


#create bar plot
# count the number of each parenthood status
parenthood_counts <- df1_filtered %>%
filter(intervention == "1") %>%
count(parenthood_status_combined) %>%
mutate(parenthood_status_combined = fct_infreq(parenthood_status_combined)) %>%
mutate(percentage = n / sum(n) * 100) # Calculate percentages

# Plot
ggplot(parenthood_counts, aes(x = parenthood_status_combined, y = n, fill = parenthood_status_combined, label = scales::percent(percentage / 100))) +
 geom_bar(stat = "identity") +
  geom_text(vjust = -0.5, size = 3.5) + # Add percentage labels
  scale_fill_manual(values = c("#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6")) +
  theme_minimal() +
 labs(x = "Parenthood Status", y = "", title = "Parenthood Status for Intervention Participants") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), # Rotate x labels for readability
      legend.position = "none", # Hide legend
     panel.grid.major = element_blank(), # Remove major grid lines
     panel.grid.minor = element_blank(), # Remove minor grid lines
      plot.caption = element_text(hjust = 1)) + # Align caption to the right
 labs(caption = "Source: PCM 2024 data") # Add source caption

```




```{r}

long_data <- df1_filtered %>%
  select(merge_id, intervention, vlsup_cat_V1, vlsup_cat_V2, vlsup_cat_V3) %>%
  pivot_longer(cols = c(vlsup_cat_V1, vlsup_cat_V2, vlsup_cat_V3), names_to = "time", values_to = "viral_load") %>%
  mutate(
    time = fct_recode(time, "Start" = "vlsup_cat_V1", "Midpoint" = "vlsup_cat_V2", "End" = "vlsup_cat_V3"),
    intervention = factor(intervention, labels = c("Control", "Intervention"))
  ) %>%
  filter(!is.na(viral_load))  # Exclude NA values

# Summarize the data to get counts
count_data <- long_data %>%
  group_by(time, intervention, viral_load) %>%
  summarise(count = n(), .groups = 'drop')

# Create the plot with specified facet layout
ggplot(count_data, aes(x = time, y = count, fill = intervention)) +
  geom_bar(stat = "identity", position = "dodge") +
  facet_wrap(~ viral_load, scales = "free_y", nrow = 2) +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.title = element_blank()
  ) +
  labs(x = "Time", y = "Count", title = "Counts by Time Point and Intervention") +
  scale_fill_manual(values = c("Control" = "#F8766D", "Intervention" = "#00BFC4"), labels = c("Control", "Intervention")) +
  scale_x_discrete(labels = c("Start", "Midpoint", "End"))



```

#creating final anaysis dataframe 
```{r}
df_stat<- df_stat <- df1_filtered %>%
  select(
    merge_id,
    age,
    sex,
    recommend_services,
    healthy_symptom_free_frequency,
    problem_experience_last_2_weeks,
    support_from_family_friends,
    hiv_discrimination_past_month,
    factors_impacted_score_most,
    hiv_treatment_expenses_loan_sold,
    preferred_hiv_services_method,
    attach_to_chw,
    parenthood_status_combined,
    intervention,
    vlsup_cat_V1,
    vlsup_cat_V2,
    vlsup_cat_V3,
  )
```


#Categorize CALHIV Participants into VLS Groups:
```{r}
# df_stat_intervention <- df_stat %>%
#   filter(intervention == "intervention")
# 
# # Categorizing participants based on viral load states, only for those with intervention
# df_stat_intervention$VLS_group <- case_when(
#   df_stat_intervention$vlsup_cat_V1 == "suppressed" & df_stat_intervention$vlsup_cat_V3 == "suppressed" ~ "Suppressed",
#   df_stat_intervention$vlsup_cat_V1 != df_stat_intervention$vlsup_cat_V3 & !is.na(df_stat_intervention$vlsup_cat_V1) & !is.na(df_stat_intervention$vlsup_cat_V3) ~ "Cycling",
#   is.na(df_stat_intervention$vlsup_cat_V1) | is.na(df_stat_intervention$vlsup_cat_V3) ~ "Data Missing", # Handle NAs if any
#   TRUE ~ "Never suppressed" # The rest are considered never suppressed
# )

```



```{r}
# categorize 3 viral load categories.

df_stat <- df_stat %>%
  mutate(VLS_group3_draws = case_when(
    vlsup_cat_V1 == "undetectable" & vlsup_cat_V2 == "undetectable" & vlsup_cat_V3 == "suppressed" ~ "suppressed",
    vlsup_cat_V1 == "suppressed" & vlsup_cat_V2 == "suppressed" & vlsup_cat_V3 == "suppressed" ~ "suppressed",
    vlsup_cat_V1 == "suppressed" & vlsup_cat_V2 == "unsuppressed" & vlsup_cat_V3 == "suppressed" ~ "cycling",
    vlsup_cat_V1 == "suppressed" & vlsup_cat_V2 == "suppressed" & vlsup_cat_V3 == "unsuppressed" ~ "unsuppressed",
    vlsup_cat_V1 == "unsuppressed" & vlsup_cat_V2 == "unsuppressed" & vlsup_cat_V3 == "unsuppressed" ~ "Never suppressed",
    vlsup_cat_V1 == "unsuppressed" & vlsup_cat_V2 == "unsuppressed" & vlsup_cat_V3 == "suppressed" ~ "suppressed",
    vlsup_cat_V1 == "unsuppressed" & vlsup_cat_V2 == "suppressed" & vlsup_cat_V3 == "suppressed" ~ "suppressed",
    vlsup_cat_V1 == "undetectable" & vlsup_cat_V2 == "suppressed" & vlsup_cat_V3 == "unsuppressed" ~ "cycling",
    vlsup_cat_V1 == "unsuppressed" & vlsup_cat_V2 == "suppressed" & vlsup_cat_V3 == "undetectable" ~ "suppressed",
    vlsup_cat_V1 == "unsuppressed" & vlsup_cat_V2 == "undetectable" & vlsup_cat_V3 == "unsuppressed" ~ "cycling",
    vlsup_cat_V1 == "unsuppressed" & vlsup_cat_V2 == "suppressed" & vlsup_cat_V3 == "unsuppressed" ~ "cycling",
    vlsup_cat_V1 == "undetectable" & vlsup_cat_V2 == "suppressed" & vlsup_cat_V3 == "suppressed" ~ "suppressed",
    vlsup_cat_V1 == "suppressed" & vlsup_cat_V2 == "suppressed" & vlsup_cat_V3 == "undetectable" ~ "suppressed",
    vlsup_cat_V1 == "unsuppressed" & vlsup_cat_V2 == "undetectable" & vlsup_cat_V3 == "undetectable" ~ "suppressed",
    vlsup_cat_V1 == "undetectable" & vlsup_cat_V2 == "unsuppressed" & vlsup_cat_V3 == "unsuppressed" ~ "unsuppressed",
    vlsup_cat_V1 == "suppressed" & vlsup_cat_V2 == "undetectable" & vlsup_cat_V3 == "suppressed" ~ "suppressed",
    vlsup_cat_V1 == "unsuppressed" & vlsup_cat_V2 == "undetectable" & vlsup_cat_V3 == "suppressed" ~ "suppressed",
    vlsup_cat_V1 == "suppressed" & vlsup_cat_V2 == "unsuppressed" & vlsup_cat_V3 == "undetectable" ~ "cycling",
    vlsup_cat_V1 == "suppressed" & vlsup_cat_V2 == "unsuppressed" & vlsup_cat_V3 == "unsuppressed" ~ "cycling",  
    vlsup_cat_V1 == "undetectable" & vlsup_cat_V2 == "undetectable" & vlsup_cat_V3 == "undetectable" ~ "suppressed",
    vlsup_cat_V1 == "undetectable" & vlsup_cat_V2 == "unsuppressed" & vlsup_cat_V3 == "suppressed" ~ "cycling",
    vlsup_cat_V1 == "suppressed" & vlsup_cat_V2 == "undetectable" & vlsup_cat_V3 == "undetectable" ~ "suppressed",
    vlsup_cat_V1 == "suppressed" & vlsup_cat_V2 == "undetectable" & vlsup_cat_V3 == "unsuppressed" ~ "cycling",
    vlsup_cat_V1 == "undetectable" & vlsup_cat_V2 == "suppressed" & vlsup_cat_V3 == "undetectable" ~ "suppressed",
    vlsup_cat_V1 == "unsuppressed" & vlsup_cat_V2 == "unsuppressed" & vlsup_cat_V3 == "undetectable" ~ "suppressed",
    vlsup_cat_V1 == "undetectable" & vlsup_cat_V2 == "suppressed" & vlsup_cat_V3 == "undetectable" ~ "suppressed",
    vlsup_cat_V1 == "undetectable" & vlsup_cat_V2 == "undetectable" & vlsup_cat_V3 == "unsuppressed" ~ "unsuppressed",
    vlsup_cat_V1 == "undetectable" & vlsup_cat_V2 == "unsuppressed" & vlsup_cat_V3 == "undetectable" ~ "cycling",
    TRUE ~ NA_character_  # This line handles cases that don't match any condition
  ))

#head(df_stat)

```


```{r}

# Set the path to the folder where you want to save the CSV
output_folder <- "C:/Users/nmaina/Documents/R.Projects/UgandaMatrixMix/Dataout"

# Define the full path to the CSV file within the output folder
output_file_path <- file.path(output_folder, "Analysis_data.csv")

# Write the vl_df1 DataFrame to the CSV file
write.csv(df1_filtered, output_file_path, row.names = FALSE)

```

